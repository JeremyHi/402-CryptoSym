[5 points] Explain your choices of data structures for the open and closed lists of your Pathfinder's graph search.
- For my open_list, I sued a list simply because I was going to be adding minimal amounts of transitions to it, at most 4, which would be the most memory efficient for large test cases.
- For the closed_list I chose to use a set as it would be faster lookup time to check if a state is contained within it than a list. Doing a set lookup is faster than a list lookup for python's `x in y`.


[15 points] Create some large, uniform-cost mazes (i.e., with no mud tiles) and run both your Uninformed Breadth-first Tree Search algorithm from CW1 and your A* Graph Search from this assignment to find a solution. Add a counter to each Pathfinder that prints out how many nodes were generated during each of the BFS and A* runs and compare the outcomes. How effective was your heuristic at mitigating computational cost?
- The heuristic function helped reduce the count of nodes generated by about half in every case, which is great cost reduction. My BFS was aided in having a pretty good caching method which helps somewhat in reduction of nodes generated, but the heuristic evaluations were a much more dominant performance metric.
